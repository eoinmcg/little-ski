<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>LittleJS Ski</title>

<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="mobile-web-app-capable" content="yes" />

<script src="https://cdn.jsdelivr.net/npm/littlejsengine@1.17.11/dist/littlejs.js"></script>
<!-- Play pico-8 tunes in js: https://github.com/codyebberson/pico8-music -->
<script src="public/js/p8-music.js"></script>
<!-- Awesome collection of CC tunes: https://www.lexaloffle.com/bbs/?tid=29008-->
<script src="public/js/tunes.js"></script>

<link rel="icon" type="image/x-icon" href="favicon.ico">

<script defer src="https://cloud.umami.is/script.js" data-website-id="6a7a59ee-cea7-4517-8aac-1aa3347fb5da"></script>

<style>
html ,body { background: #333; }
#pause-ui {
  position: fixed;
  inset: 0;
  z-index: 10001;
  transition:
  display 1s allow-discrete,
  overlay 1s allow-discrete,
  opacity 1s ease,
  pointer-events 1s allow-discrete;
  pointer-events: auto;
}
/* The "Entrance" state */
@starting-style {
  #pause-ui { opacity: 0; pointer-events: none; }
  #pause-ui #pause-panel { top: -100%; }
}

#pause-ui[hidden] {
  display: none;
  opacity: 0;
  pointer-events: none;
}

#pause-backdrop {
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,.5);
}

#pause-ui #pause-panel {
  position: relative;
  top: 40%;
  transition: top 1s ease;
}
#pause-ui[hidden] #pause-panel { top: -100%; }

#pause-panel {
  inset: 0;
  font-family: monospace;
  border: 5px solid #fff;
  margin: auto;
  width: min(90vw, 320px);
  height: fit-content;
  background: #222;
  padding: 1em;
  border-radius: 12px;
  color: white;
  z-index: 999999;
  box-shadow: 5px 5px 0px black;
}
#pause-panel { font-size: clamp(18px, 2.5vw, 20px); min-width: 280px; border-radius: 10px; }
#pause-panel h1 { font-size: 1.6em; margin: 0 0 1rem 0; }
#pause-panel h2 { font-size: 1.25em; }
#pause-panel label { 
  display: block; width: 100%;
  padding: .5rem 0;
  border-radius: 5px;
}
#pause-panel label.clear-scores { padding-left: 2rem; width: 90%; }
#pause-panel label:hover { cursor: pointer; background: yellow; color: black; }
#pause-panel label input { margin-right: 1rem; }
#pause-panel button {
  position: absolute;
  top: 10px;
  right: 10px;
  text-indent: -99999rem;
  background: #efefef;
  border: 2px solid black;
  border-radius: 5px;
  width: 32px; height: 32px;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40px' height='40px' viewbox='0 0 40 40'%3E%3Cpath d='M 10,10 L 30,30 M 30,10 L 10,30' stroke='black' stroke-width='4' stroke-linecap='butt' /%3E%3C/svg%3E");
  background-size: 100%;
}
#pause-panel button:hover {
  cursor: pointer;
  background-color: orange;
  color: #fff;
}
</style>

</head>
<body>

<script>
'use strict';

// naughty, naughty
Array.prototype.rnd = function () {
  return this[Math.floor((Math.random()*this.length))];
}

let hiScore = 10;
try {
  hiScore = window.localStorage.getItem('hiScore') || hiScore;
} catch (e) {}

const G = {
  width: 20, height: 30,
  tileSize: 16,
  tiles: ['public/ski_tiles.png', 'public/title.png'],
  cols: {
    white: new Color().setHex('#ffffff'),
    red: new Color().setHex('#ff004d'),
    pink: new Color().setHex('#ffc0cb'),
    yellow: new Color().setHex('#ffff00'),
    snow: new Color().setHex('#cfe7f7'),
    lightBlue: new Color().setHex('#29adff'),
    slate: new Color().setHex('#343635'),
    skyLight: new Color().setHex('#ffccaa'),
    skyMed: new Color().setHex('#ff77a8'),
    skyDark: new Color().setHex('#ff004d'),
  },
  sfx: {
    play: function(name, pos = false) {
      if (!G.mute) {
        G.sfx[name].play(pos);
      }
    },
    ski: new Sound([.25,.5,40,.5,,.2,,11,,,,,,199]),
    hit: new Sound([2.1,,156,.01,.01,.3,2,.6,,,,,,1.3,,.2,.14,.45,.01,,150]),
    pickup: new Sound([1.4,,428,,.05,.08,1,1.9,,,442,.04,,,,,.03,.87,.03,,-1399]),
  },
  hiScore: parseInt(hiScore, 10),
  plays: -1,
  splash: true,
  fullscreen: false,
  mute: false,
  shake: {
    time: 0,
    force: .4,
  },
}

G.medals = [
  new Medal(0, 'Hiscore', 'GOT A HISCORE!', 'ðŸ¥‡')
];

if (window.location.hostname !== 'localhost') {
  setShowSplashScreen(true);
  setDebugWatermark(false);
}

G.tunes = new P8(Tunes.i, Tunes.m);

function gameInit() {
  const gameSize = vec2(G.width * G.tileSize, G.height * G.tileSize);
  setCanvasFixedSize(gameSize);

  // Set camera scale so the full design height fits the screen
  cameraScale = G.tileSize; // pixels per world unit

  setCanvasPixelated(true);
  setTileDefaultBleed(.5);


  medalsInit('little-ski');
  medalsForEach(medal=> medal.unlocked = false);

  let snowflakes = 20;
  while(snowflakes--) { new Snow(G); }

}

function startGame() {
  inputClear();
  engineObjectsDestroy();   // remove all engine objects

  G.speed = 0.1;
  G.score = 0;
  G.nextSpawn = 0;

  G.plays += 1;
  G.newHiscore = false;

  // background
  let halfH = G.height / 2;
  let halfW = G.width / 2;
  for (let y = -halfH; y <= halfH; y += 1) {
    for (let x = -halfW; x <= halfW; x += 1) {
      if (Math.random() > .95) {
        new Bg(vec2(x, y), G);
      }
    }
  }
  if (!G.mute) {
    playTune(false, 10);
  }
  G.player = new Player(G);
  G.splash = false;
  G.newHiscore = false;

}

function playTune(tune = false, delay = 0) {
  if (G.mute) { return; }
  if (G.audio) { G.audio.stop(); }
  tune = tune || [14, 18, 24, 48].rnd();
  window.setTimeout(() => {
    G.audio = G.tunes.music(tune);
  }, delay);
}

function splashUpdate() {
  if (mouseWasReleased(0) || keyWasReleased('Space')) {
      startGame();
  }
}

function splashRender() {

  // drawRectGradient(vec2(), vec2(G.width, G.height), G.cols.skyDark, G.cols.skyMed)
  // drawRectGradient(vec2().add(vec2(0,-4)), vec2(G.width, G.height/4), G.cols.skyLight, CLEAR_BLACK)

  // drawRectGradient(vec2(0, 15), vec2(G.width, 7), new Color(0,0,0,1), new Color(0,0,0, .01));
  drawRect(vec2(), vec2(G.width, G.height), G.cols.skyDark);
  drawRect(vec2().add(vec2(0,-4)), vec2(G.width, G.height/2), G.cols.skyMed)
  drawRect(vec2().add(vec2(0,-7)), vec2(G.width, G.height/4), G.cols.skyLight)

  // bg mtns
  drawRect(vec2(-8, -10), vec2(6, 6), G.cols.slate, PI/4)
  drawRect(vec2(8, -10), vec2(7), G.cols.slate, PI/4)

  drawRect(vec2(0, -14), vec2(18, 18).add(vec2(.75)), G.cols.slate, PI/4)
  drawRect(vec2(0, -14), vec2(18, 18), G.cols.lightBlue, PI/4)
  drawRect(vec2(0, -4), vec2(4, 4), WHITE, PI/4)
  drawRect(vec2(2.4, -5), vec2(2, 2), WHITE, PI/4)
  drawRect(vec2(-2.4, -5), vec2(2, 2), WHITE, PI/4)
  drawRect(vec2(3.2, -5.5), vec2(1.5), WHITE, PI/4)
  drawRect(vec2(-3.2, -5.5), vec2(1.5), WHITE, PI/4)

    renderHiScore();
}

function showPauseUI() {
  inputClear();
  setPaused(true);
  G.pauseUI.hidden = false;
  if (!G.audio) return;
  G.audio.playbackRate.value = 0;
}

function hidePauseUI() {
  inputClear();
  G.pauseUI.hidden = true;
  setPaused(false);
  if (!G.audio || G.mute) return;
  G.audio.playbackRate.value = 1;
}

function toggleMute() {
  G.mute = !G.mute;
  G.muteCheckbox.checked = G.mute;
  if (!G.audio) return;
  if (G.mute) { G.audio.playbackRate.value = 0; return; }
  if (!G.mute && !G.player.crashed) {
    playTune();
    window.setTimeout(() => {
      G.audio.playbackRate.value = getPaused() ? 0 : 1;
    }, 100)
  }
}

function gameUpdate() {

  if (G.splash) { return splashUpdate(); }

  G.score += G.speed / 10;

  if (G.player && !G.player.crashed) {
    G.speed += G.score / 100000;
    G.speed = clamp(G.speed, 0.1, 0.3);
  }
  G.nextSpawn += G.speed;

  if (G.nextSpawn > 3) {
    G.nextSpawn = 0;
    if (Math.random() > .75) { new Tree(G); }
    if (Math.random() > .95) { new Treat(G); }
  }

  if (G.score > G.hiScore && !G.newHiscore) {
    console.log('NEW HI');
    G.medals[0].unlock();
    G.newHiscore = true;
  }

  if (G.score > G.hiScore && G.player.crashed) {
    G.hiScore = Math.floor(G.score);
    try {
      window.localStorage.setItem('hiScore', G.hiScore)
    } catch (e) {}
  }

  if (G.player.crashed
    && time > G.player.crashed + 2
    && (mouseWasPressed(0) || keyWasPressed('Space'))) {
    startGame();
  }

  if (G.player && G.player.crashed
    && time > G.player.crashed + 20) {
    engineObjectsDestroy();
    G.audio.stop();
    G.splash = true;
  }

}

function gameUpdatePost() {

  if (keyWasReleased('KeyM')) {
    toggleMute();
  }

  const mousePause = mouseWasPressed(0) && mousePos.y > 11;
  if (keyWasReleased('KeyP') || keyWasReleased('KeyEsc') || mousePause) {
    if (G.pauseUI.hidden) {
      showPauseUI();
    } else {
      hidePauseUI();
    }
  }


  let shakeOffset = vec2();

  if (G.shake.time > 0) {
    G.shake.time -= timeDelta;
    shakeOffset = randVec2(G.shake.strength);
    setCameraPos(vec2().add(shakeOffset));
  } else if (G.shake.time < 0) {
    setCameraPos(vec2());
  }
}

function gameRender() {

  if (G.splash) {
    splashRender();
    return;
  }

  drawRect(vec2(0), vec2(G.width, G.height), G.cols.snow);
}

function gameRenderPost() {
  const font = engineFontImage;
  if (G.splash) {
    funkyText('LITTLE', vec2(2.7,10.7), 3, false, G);
    funkyText('SKI', vec2(6,7), 5, false, G);
    if (Math.sin(time*5) > 0) {
      let pos = cameraPos.copy();
      font.drawText(`READY?`, pos.add(vec2(0,-.15)), 1.3, true, BLACK);
      font.drawText(`READY?`, pos, 1.3, true);
    }
    font.drawText(`code: eoinmcg`, cameraPos.add(vec2(-9, -12.5)), .7, false);
    font.drawText(`gfx: kenney.nl`, cameraPos.add(vec2(-9, -13.25)), .7, false);
    font.drawText(`music: @gruber_music`, cameraPos.add(vec2(-9, -14)), .7, false);
    return;
  }

  // pause
  let pos = vec2((G.width / 2) - 1.5, (G.height / 2) - 1.5);
  drawTile(pos, vec2(2), tile(88));
  // let size = vec2(.5, 1.5)
  // drawRect(pos, size, BLACK);
  // drawRect(pos.add(vec2(1 ,0)), size, BLACK);

  // left pad the score with 0s, so we have 0001 etc
  let score = Math.floor(G.score).toString().padStart(4, '0')
  // position the score at top center
  let startPos = cameraPos.copy().add(vec2(-3,13))
  score.split('').forEach((num, index) => {
    num = parseInt(num, 10); // cast num as an int so we can add it to the frame
    drawTile(
      startPos.add(vec2(index * 1.75, 0)),
      vec2(2.5), // digit size
      tile(96 + num, G.tileSize), // 96 is the frame for 0
    );
  });

  if (G.player && G.player.crashed) {
    funkyText('GAME OVER', vec2(0,-3), 2, true, G);
    renderHiScore();
  }
}


function renderHiScore() {
    const font = engineFontImage;
  font.drawText('HI:'+G.hiScore, vec2(0,-10.1), 1.1, true, WHITE);
  font.drawText('HI:'+G.hiScore, vec2(0,-10), 1.1, true, BLACK);
}

class Player extends EngineObject {
  constructor(game) {
    let size = 1.7;
    frame = Math.random() > .5 ? 70 : 82;
    super(
      vec2(0, 7),
      vec2(size),
      tile(frame, game.tileSize)
    );

    this.minX = (game.width-2) / -2;
    this.maxX = (game.width-2) / 2;

    // horizontal direction of player
    this.dir = 0;

    // an array of previous player position
    this.trail = [];
    this.trailCol = new Color(1, 1, 1, 0.25);

    this.frame = frame;
    this.setCollision(true, true, false, false);

    this.game = game;
    this.shadow = new Color(0,0,0,0.1);
  }

  update() {
    super.update();
    // some basic animation
    this.currentFrame = (Math.sin(time * 7) > 0)
      ? this.frame : this.frame + 1;

    if (this.crashed) return;

    const muteButton = mousePos.y > 27 && mousePos.x > 17;
    if ((mouseWasPressed(0) || keyWasPressed('Space')) && !muteButton) {
      particlesMove(this.pos, this.angle, this.game);
      this.game.sfx.play('ski', this.pos);
      this.dir = (this.dir === 0)
        ? -1 : this.dir *= -1;
    }

    // gradually increase x speed
    this.velocity.x += (this.dir * .015);

    // clamp x speed
    this.velocity.x = clamp(this.velocity.x, -.3, .3);

    // update angle based on exaggerated velocity
    this.angle = -this.velocity.x * 2.5;

    // check for out of bounds
    if (this.pos.x <= this.minX
      || this.pos.x >= this.maxX) {
      // slightly bump player away from screen edge
      this.pos.x -= this.velocity.x * 1;
      // reduce x speed
      this.velocity.x *= -.1;
      // change direction
      this.dir *= -1;
    }

    this.trail.push({pos: this.pos.copy(), angle: this.angle});
    // remove any entries that are now off screen
    this.trail.forEach((t, i) => {
      t.pos.y += this.game.speed;
      if (t.pos.y > this.game.height) {
        this.trail.splice(i, 1);
      }
    });
  }

  render() {
    this.trail.forEach((t) => {
      drawTile(t.pos, vec2(2),
        tile(58, this.game.tileSize),
        this.trailCol, t.angle);
    });

    if (!this.crashed) {
      // shadow
      drawCircle(this.pos.add(vec2(0,-1)), 2, this.shadow);
      // left ski
      drawRect(this.pos.add(vec2(-.4, -.5)), vec2(.4, 2.4), BLACK, this.angle);
      drawRect(this.pos.add(vec2(-.4, -.5)), vec2(.2, 2), ORANGE, this.angle);
      // right ski
      drawRect(this.pos.add(vec2(.4, -.5)), vec2(.4, 2.4), BLACK, this.angle);
      drawRect(this.pos.add(vec2(.4, -.5)), vec2(.2, 2), ORANGE, this.angle);
    }

    drawTile(this.pos, this.size,
      tile(this.currentFrame, G.tileSize),
      undefined, this.angle);
  }

  collideWithObject(o) {
    if (this.crashed) return;

    if (o.constructor.name === 'Treat') {
      this.game.sfx.play('pickup', this.pos);
      o.destroy();
      particlesCollect(this.pos, this.game);
      this.game.score += 10;
      return;
    }

    particlesCrash(this.pos, this.game);
    this.game.shake.time = .3;
    this.game.sfx.play('hit', this.pos);
    this.game.speed = 0;
    this.velocity.x = 0;
    this.angle = 0;
    this.frame = 94;
    this.crashed = time;
    playTune(36, 1000);
  }
}

class Tree extends EngineObject {
  constructor(game) {
    let x = game.width / 2;
    let y = game.height / 2;

    let pos = vec2(rand(-x, x), -y-2);
    let frame = 30;
    super(pos, vec2(.5), tile(frame, game.tileSize));

    this.game = game;
    this.setCollision(true, false, false, false);
    this.shadow = new Color(0,0,0,0.1);
  }

  update() {
    super.update();
    this.pos.y += this.game.speed;

    // remove object when past top of screen
    if (this.pos.y > this.game.height / 2) {
      super.destroy();
    }
  }

  render() {
    drawCircle(this.pos.add(vec2(0,-.5)), 2, this.shadow);
    drawTile( this.pos.add(vec2(0,.5)), vec2(2), tile(30, G.tileSize)) 
  }
}

class Treat extends EngineObject {
  constructor(game) {
    let frame = [90].rnd();
    let x = game.width / 2;
    let y = game.height / 2;

    let pos = vec2(rand(-x, x), -y-2);
    super(pos, vec2(2), tile(frame, 16));
    this.game = game;
    this.frame = frame;

    this.setCollision(true, false, false, false);
  }

  update() {
    this.wave = Math.abs(Math.sin(new Date().getTime() * 0.0005));
    super.update();
    this.pos.y += this.game.speed;
    if (this.pos.y > this.game.height / 2) {
      this.destroy();
    }
  }

  render() {
    // image
    drawTile(this.pos.add(vec2(0, -.5)), vec2(3, 1.5), tile(107, 16), undefined, 0, new Color(0,0,0,1));
    // shadow
    drawTile(this.pos.add(vec2(0, this.wave)), vec2(1.5), tile(this.frame, 16));
  }
}

class Bg extends EngineObject {
  constructor(pos, game) {
    super(pos, vec2(rand(1,3)), tile(3, game.t))
    this.renderOrder = 0;
    this.game = game;
  }

  update() {
    super.update();
    this.pos = this.pos.add(vec2(0, this.game.speed));

    if (this.pos.y > (this.game.height+4) / 2) {
      this.pos.y = (this.game.height+4) / -2;
      this.mirror = !this.mirror;
    }
  }
}

class Snow extends EngineObject {
  constructor(game) {
    let x = game.width / 2;
    let y = game.height / 2;
    super(vec2(rand(-x, x), rand(-y, y)),
      vec2(rand(.25,1.5)), tile(84, game.tileSize))
    this.renderOrder = 0;
    this.game = game;
    this.speed = this.size.x / 20;
    this.startX = this.pos.x
  }

  update() {
    super.update();
    let x = this.startX + (Math.sin(time * .005))
    this.pos = this.pos.add(vec2(0, -this.speed));
    this.pos.x = this.startX + (Math.sin(time * this.speed * 15));

    if (this.pos.y < (this.game.height / -1.8)) {
      this.pos.y = this.game.height / 2;
      this.mirror = !this.mirror;
    }
  }
}

const particlesCrash = (pos, game) => {
  let col = new Color();
  new ParticleEmitter(
    pos, 0,            // pos, angle
    0, .2, 15, 1, // emitSize, emitTime, emitRate, emiteCone
    tile(86,16),                      // tileInfo
    game.cols.white, game.cols.snow,           // colorStartA, colorStartB
    game.cols.white.scale(0,0), game.cols.snow.scale(0,0), // colorEndA, colorEndB
    1, 5, 8, 0, 0.01,  // time, sizeStart, sizeEnd, speed, angleSpeed
    1, 1, 0, 1,   // damping, angleDamping, gravityScale, cone
    .1, 0.1, 0, 1        // fadeRate, randomness, collide, additive
  );
}

const particlesMove = (pos, angle, game, num = 30) => {
  new ParticleEmitter(
    vec2(pos.x, pos.y + 1), -angle,            // pos, angle
    0, .2, num, 1, // emitSize, emitTime, emitRate, emiteCone
    tile(107,16),                      // tileInfo
    game.cols.white, game.cols.snow,           // colorStartA, colorStartB
    game.cols.white.scale(1,0), game.cols.snow.scale(1,0), // colorEndA, colorEndB
    1, 1, .5, .1, 0,  // time, sizeStart, sizeEnd, speed, angleSpeed
    1, 1, 0, 1,   // damping, angleDamping, gravityScale, cone
    .1, 0, 0, 1        // fadeRate, randomness, collide, additive
  );
}

const particlesCollect = (pos, game) => {
  new ParticleEmitter(
    pos, 0,            // pos, angle
    0, .2, 15, 0.2, // emitSize, emitTime, emitRate, emiteCone
    tile(85,16),                      // tileInfo
    game.cols.red, game.cols.yellow, // colorStartA, colorStartB
    game.cols.red, game.cols.yellow, // colorEndA, colorEndB
    1, 2, .5, game.speed * 1.5, .02,  // time, sizeStart, sizeEnd, speed, angleSpeed
    1, 1, 0, 0,   // damping, angleDamping, gravityScale, cone
    .1, .1, 0, 0        // fadeRate, randomness, collide, additive
  );
}

/**
 *  Draws some funky text
 *  go crazy (if you want)
 *  @param {String}  text
 *  @param {Vector2} [pos=camerPos]
 *  @param {Number}  [scale=2]
 *  @param {Boolean}   [crazy=true]
 *  @param {Object}   [game]
 *  */
function funkyText(str, pos=cameraPos, scale = 2, crazy = true, game) {
  let wave = crazy ? Math.sin(new Date().getTime() * 0.005) : 0;
  let startX = str.length * .5;
  let cols = game.splash
    ? [game.cols.white, game.cols.white]
    : [game.cols.red, game.cols.yellow];
  let offset = 108 - 65; // 108 is A on the tileset - 65 is charCode for A
  str.toUpperCase().split('').forEach((letter, i) => {
    let l = letter.charCodeAt(0) + offset;
    let col = wave > 0 ? cols[0] : cols[1];
    if (crazy && wave > 0) {
      if (i % 2) {
        if (col === cols[0]) col = cols[1];
      } else {
        if (col === cols[1]) col = cols[0];
      }
    } else if (crazy && wave < 0) {
      if (i % 2) {
        if (col === cols[1]) col = cols[0];
      } else {
        if (col === cols[0]) col = cols[1];
      }
    }
    if (letter !== ' ') {
      let a = (crazy) ? wave / 20 : 0, // letter angle
      x = startX + (i * scale * .7) - (game.width / 2),
      y = a * (i + 1) * 2;
      y = (Math.sin(x) / 5) + wave / 10;
      drawTile(pos.add(vec2(x, y)), vec2(scale), tile(l, 16), col, a);
    }
  });
}

addEventListener("DOMContentLoaded", () => {

  G.modalBackdrop = document.querySelector('#pause-backdrop');
  G.modalDialog = document.querySelector('#pause-panel');
  G.pauseUI = document.getElementById('pause-ui');
  G.modalDialogClose = G.pauseUI.querySelector('button');

  G.modalDialogClose.addEventListener('click', (e) => {
    hidePauseUI();
  });

  G.muteCheckbox = G.modalDialog.querySelector('input[name="mute"]');
  G.muteCheckbox.addEventListener('change', e => {
    toggleMute();
  });

  const fullscreenCheckbox = G.modalDialog.querySelector('input[name="fullscreen"]');
  fullscreenCheckbox.addEventListener('change', e => {
    G.fullscreen = e.target.checked;
    const root = document.querySelector('#game-root');

    if (G.fullscreen)
      root.requestFullscreen();
    else
      document.exitFullscreen();
  });

  const clearScores = G.modalDialog.querySelector('label.clear-scores');
  clearScores.addEventListener('click', e => {
    G.sfx.play('hit');
    try {
      window.localStorage.clear();
      G.hiScore = 10;
      G.newHiscore = false;
    } catch(e) { }
  });

  document.addEventListener('fullscreenchange', () => {
    window.setTimeout(() => {
      // sync checkbox
      fullscreenCheckbox.checked = (document.fullscreenElement !== null)
    }, 500)
  });

  engineInit(
    gameInit,
    gameUpdate, gameUpdatePost,
    gameRender, gameRenderPost,
    G.tiles,
    document.querySelector('#game-root'),
  );
  console.log('-----------------------')
  console.log('Wanna see how this game was made? Check out the tutorial:')
  console.log('https://eoinmcgrath.com/little-ski/tutorial.html')
});


</script>

<div id="game-root">
  <div id="pause-ui" hidden>
    <div id="pause-backdrop"></div>
    <div id="pause-panel">
      <button>Close</button>
      <h1>Paused</h1>
      <label>
        <input type="checkbox" name="fullscreen" id="fullscreenToggle">
        Fullscreen
      </label>
      <label>
        <input type="checkbox" name="mute" id="muteToggle">
        Mute
      </label>
      <label class="clear-scores">
            Clear scores
      </label>
    </div>
  </div>
</div>

</body>
</html>
